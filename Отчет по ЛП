# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Макаров В.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Опишите, какие знания и навыки вы получите в результате выполнения курсового проекта

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: ...
 3. Реализовать предикат проверки/поиска .... 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Для получения родословного дерева я использовал сайт myheritage.ru, который преобразует информацию из интуитивно-понятной визуальной формы в формат GEDCOM. В моем дереве получилось 42 человека. Часть людей, информации о которых не нашлось, были заменены вымышленными именами.

## Конвертация родословного дерева

Для обработки GEDCOM-файла я использовал язык python. Выполнение парсинга на других языках программирования также возможно, но я выбрал удобный для составления короткой и лакончиной программы язык. Для решения этой задачи я использовал готовые библиотеки python-gedcom, находящиеся в свободном доступе в интернете.

главная часть кода:

```python
for element in root_child_elements:
if isinstance(element, IndividualElement):
if len(gedcom_parser.get_parents(element, "ALL")) != 0:
(father, mother) = gedcom_parser.get_parents(element, "ALL")
(child_first_name, child_last_name) = element.get_name()
(father_first_name, father_last_name) = father.get_name()
(mother_first_name, mother_last_name) = mother.get_name()
facts.write('parents(' + child_first_name + ' ' + child_last_name + ',' + father_first_name + ' ' + father_last_name + ', ' + mother_first_name + ' ' + mother_last_name + ')\n')
```
Основной принцип работы следующий - при помощи стандартных методов библиотеки (root_child_elements - список всех потомков, get_parents - получение родителей конкретного потомка, get_name - получение имени, и.т.д.) проходимся по всем потомкам в списке, получая информацию о его родителях, и записываем полученную информацию в итоговый файл в необходимом виде, т.е. в форме фактов для языка prolog.
Я выбрал такой способ решения, поскольку данная библиотека обладает всеми необходимыми методами для парсинга GEDCOM файла, позволяя сделать программу интуитивно-понятной.
Информация о библиотеке:
https://pypi.org/project/python-gedcom/0.2.5.dev0/

## Предикат поиска родственника

Предикат поиска двоюродного брата.

Поскольку мы имеем факты в форме parents(child,father,mother) удобнее и эффективнее всего будет использовать дополнительные предикаты (они пригодятся и в последующих заданиях).

Предикат cild(Name,X) // ищет родителей (Name) для выбранного потомка (X) 
Мы можем найти их по местоположению в описанных фактах.

```prolog
child(Name,X) :- parents(Name, X, _ ); parents(Name, _ , X).
```

Предикат sibling(Name,X) // ищет братьев/сестер (Name) для выбранного человека (X)
Найти их можно, сопоставив всех потомков, имеющих одних и тех же родителей.

```prolog
sibling(Name,X) :-parents(Name, A,B), parents(X, A, B),
Name \= X.
```
Главный предикат: cousin(Name,X) // ищет двоюродных братьев (Name) для выбранного человека (X)
При реализации предиката я столкнулся с проблемой: поскольку родство у нас задано предикатом parents(child, father, mother), у нас нет информации о том, какого пола тот или иной объект child. Единственный способ узнать пол - если у этого потомка есть свои дети, тогда мы можем определить пол, узнав отец это или мать. Но если у потомка нет своих детей, то есть как минимум 3 варианта решения этой проблемы: введение дополнительного предиката для пола, добавление фиктивных потомков или игнорирование объектов, не имеющих потомков. 
Я думаю, что, в общем случае,самым полным и правильным способом было бы введение дополнительного предиката для пола, но посмотрев на своей конкретный пример, я заметил, что у всех, кто мог бы быть кому-либо двоюродным братом, за редким исключением, есть потомки. Поэтому, разрабатывая решение для своей конкретной задачи я выбрал третий вариант - игнорировать тех, у кого нет потомков. Для этого добавляем условие parents(_ ,Name,_ ) - кандидат является кому-то отцом. 

```prolog
cousin(Name,X) :- ((sibling(A,B), child(Name,A), child(X,B),parents(_ ,Name,_ ));
(sibling(A,B), child(X,A), child(Name,B), parents(_ ,Name,_ ))),
Name \= X.
```
Пример использования:

```prolog
parents('Александр Макаров','Борис Макаров', 'Елизавета Макарова').
parents('Валерий Макаров','Александр Макаров', 'Елена Макарова').
parents('Елена Макарова','Кузьма Титов', 'Вера Титова').
parents('Борис Макаров','Алексей Макаров', 'Светлана Макарова').
parents('Алексей Макаров','Вячеслав Макаров', 'Ольга Макарова').
parents('Вячеслав Макаров','Виктор Макаров', 'Виктория Макарова').
parents('Владимир Макаров','Борис Макаров', 'Елизавета Макарова').
parents('Сергей Макаров','Владимир Макаров', 'Александра Мышляева').
parents('Антон Макаров','Алексей Макаров', 'Светлана Макарова').
parents('Иван Макаров','Антон Макаров', 'Анастасия Акчурина').
parents('Анастасия Акчурина','Ренат Акчурин', 'Анна Акчурина').
parents('Анна Акчурина','Артур Акчурин', 'Лера Акчурина').
parents('Игорь Акчурин','Артур Акчурин', 'Лера Акчурина').
parents('Олег Акчурин','Игорь Акчурин','  ').
parents('Григорий Макаров','Виктор Макаров', 'Виктория Макарова').
parents('Алексей Макаров','Григорий Макаров', 'Анна Пономарева').
parents('Вера Титова','Александр Володьков', 'Татьяна Володькова').
parents('Татьяна Володькова','Анатолий Володьков', 'Анна Володькова').
parents('Ольга Володькова','Анатолий Володьков', 'Анна Володькова').
parents('Аркадий Володьков','Павел Володьков', 'Ольга Володькова').
parents('Алиса Макарова','Владимир Макаров', 'Александра Мышляева').
parents('Иван Володьков','Александр Володьков', 'Татьяна Володькова').
parents('Федор Макаров','Сергей Макаров', 'Юлия Макарова').
parents('Арсений Володьков','Иван Володьков', 'Людмила Володькова').

```
_______________________

?- child(Name, 'Александр Макаров').

Name = 'Валерий Макаров'

?- sibling(Name, 'Александр Макаров').

Name = 'Владимир Макаров'

?- child(Name, 'Владимир Макаров').

Name = 'Сергей Макаров'

Name = 'Алиса Макарова'

?- cousin(Name, 'Валерий Макаров').

Name = 'Сергей Макаров'

?- cousin('Алиса Макарова','Валерий Макаров').

false

?- cousin('Сергей Макаров','Валерий Макаров').

true



## Определение степени родства

Приведите описание метода решения, важные фрагменты исходного кода, протокол работы.

## Естественно-языковый интерфейс

## Выводы

Сформулируйте *содержательные* выводы по курсовому проекту в целом. Чему он вас научила? 
Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки.
